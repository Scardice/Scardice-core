package sealcrypto

import (
	"crypto/sha256"
	"encoding/hex"
	"io"
	"regexp"
	"testing"

	"github.com/dop251/goja"
	"github.com/dop251/goja_nodejs/require"
	"golang.org/x/crypto/hkdf"
)

func mustPromiseFulfilled(t *testing.T, v goja.Value) goja.Value {
	t.Helper()
	p, ok := v.Export().(*goja.Promise)
	if !ok {
		t.Fatalf("expected Promise, got %T", v.Export())
	}
	if p.State() != goja.PromiseStateFulfilled {
		t.Fatalf("promise not fulfilled, state=%v result=%v", p.State(), p.Result())
	}
	return p.Result()
}

func mustRun(t *testing.T, vm *goja.Runtime, src string) goja.Value {
	t.Helper()
	v, err := vm.RunString(src)
	if err != nil {
		t.Fatalf("RunString failed: %v", err)
	}
	return v
}

func TestGetRandomValues(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	v := mustRun(t, vm, `(function(){const a = new Uint8Array(32); crypto.getRandomValues(a); return a;})()`)
	bytesData, ok := v.Export().([]byte)
	if !ok {
		t.Fatalf("unexpected type: %T", v.Export())
	}
	if len(bytesData) != 32 {
		t.Fatalf("unexpected length: %d", len(bytesData))
	}
	allZero := true
	for _, b := range bytesData {
		if b != 0 {
			allZero = false
			break
		}
	}
	if allZero {
		t.Fatal("generated bytes are all zero")
	}
}

func TestDigestSupportsMD5(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	v := mustRun(t, vm, `crypto.subtle.digest("MD5", new Uint8Array([97,98,99]))`)
	result := mustPromiseFulfilled(t, v)
	ab, ok := result.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected digest type: %T", result.Export())
	}
	if got := hex.EncodeToString(ab.Bytes()); got != "900150983cd24fb0d6963f7d28e17f72" {
		t.Fatalf("unexpected md5 digest: %s", got)
	}
}

func TestGenerateSignVerifyHMACSHA1(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"HMAC", hash:{name:"SHA-1"}, length:160},
			true,
			["sign","verify"]
		)
	`))
	_ = vm.Set("k", k)

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign("HMAC", k, new Uint8Array([1,2,3,4]))
	`))
	_ = vm.Set("sig", sig)

	ok := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify("HMAC", k, sig, new Uint8Array([1,2,3,4]))
	`))
	if !ok.ToBoolean() {
		t.Fatal("HMAC verify failed")
	}
}

func TestAESCBCEncryptDecrypt(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"AES-CBC", length:128},
			true,
			["encrypt","decrypt"]
		)
	`))
	_ = vm.Set("k", k)

	mustRun(t, vm, `globalThis.iv = new Uint8Array(16); crypto.getRandomValues(globalThis.iv);`)
	enc := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.encrypt(
			{name:"AES-CBC", iv: globalThis.iv},
			k,
			new Uint8Array([104,101,108,108,111])
		)
	`))
	_ = vm.Set("enc", enc)

	dec := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.decrypt(
			{name:"AES-CBC", iv: globalThis.iv},
			k,
			enc
		)
	`))
	ab, ok := dec.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected decrypt type: %T", dec.Export())
	}
	if string(ab.Bytes()) != "hello" {
		t.Fatalf("unexpected plaintext: %q", string(ab.Bytes()))
	}
}

func TestAESGCMEncryptDecryptNon12IV(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"AES-GCM", length:128},
			true,
			["encrypt","decrypt"]
		)
	`))
	_ = vm.Set("k", k)
	mustRun(t, vm, `globalThis.ivGcm16 = new Uint8Array(16); crypto.getRandomValues(globalThis.ivGcm16);`)

	enc := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.encrypt(
			{name:"AES-GCM", iv: globalThis.ivGcm16},
			k,
			new Uint8Array([104,101,108,108,111])
		)
	`))
	_ = vm.Set("enc", enc)

	dec := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.decrypt(
			{name:"AES-GCM", iv: globalThis.ivGcm16},
			k,
			enc
		)
	`))
	ab, ok := dec.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected AES-GCM decrypt type: %T", dec.Export())
	}
	if string(ab.Bytes()) != "hello" {
		t.Fatalf("unexpected AES-GCM plaintext: %q", string(ab.Bytes()))
	}
}

func TestDESCBCEncryptDecrypt(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"DES-CBC", length:64},
			true,
			["encrypt","decrypt"]
		)
	`))
	_ = vm.Set("k", k)

	mustRun(t, vm, `globalThis.ivDes = new Uint8Array(8); crypto.getRandomValues(globalThis.ivDes);`)
	enc := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.encrypt(
			{name:"DES-CBC", iv: globalThis.ivDes},
			k,
			new Uint8Array([104,101,108,108,111])
		)
	`))
	_ = vm.Set("enc", enc)

	dec := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.decrypt(
			{name:"DES-CBC", iv: globalThis.ivDes},
			k,
			enc
		)
	`))
	ab, ok := dec.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected DES decrypt type: %T", dec.Export())
	}
	if string(ab.Bytes()) != "hello" {
		t.Fatalf("unexpected DES plaintext: %q", string(ab.Bytes()))
	}
}

func Test3DESCBCEncryptDecryptAlias(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey(
			"raw",
			new Uint8Array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),
			"DES-EDE3-CBC",
			true,
			["encrypt","decrypt"]
		)
	`))
	_ = vm.Set("k", k)

	mustRun(t, vm, `globalThis.iv3Des = new Uint8Array(8); crypto.getRandomValues(globalThis.iv3Des);`)
	enc := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.encrypt(
			{name:"DES-EDE3-CBC", iv: globalThis.iv3Des},
			k,
			new Uint8Array([104,101,108,108,111])
		)
	`))
	_ = vm.Set("enc", enc)

	dec := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.decrypt(
			{name:"3DES-CBC", iv: globalThis.iv3Des},
			k,
			enc
		)
	`))
	ab, ok := dec.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected 3DES decrypt type: %T", dec.Export())
	}
	if string(ab.Bytes()) != "hello" {
		t.Fatalf("unexpected 3DES plaintext: %q", string(ab.Bytes()))
	}
}

func TestRSAESPKCS1v15EncryptDecrypt(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"RSAES-PKCS1-v1_5", modulusLength:1024, publicExponent:new Uint8Array([1,0,1]), hash:{name:"SHA-1"}},
			true,
			["encrypt","decrypt"]
		)
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pub", pairObj.Get("publicKey"))
	_ = vm.Set("pri", pairObj.Get("privateKey"))

	enc := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.encrypt("RSAES-PKCS1-v1_5", pub, new Uint8Array([97,98,99]))
	`))
	_ = vm.Set("enc", enc)

	dec := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.decrypt("RSAES-PKCS1-v1_5", pri, enc)
	`))
	ab, ok := dec.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected decrypt type: %T", dec.Export())
	}
	if string(ab.Bytes()) != "abc" {
		t.Fatalf("unexpected plaintext: %q", string(ab.Bytes()))
	}
}

func TestRSAESPKCS1v15EncryptDecryptWithoutHashParam(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"RSAES-PKCS1-v1_5", modulusLength:1024, publicExponent:new Uint8Array([1,0,1])},
			true,
			["encrypt","decrypt"]
		)
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pub", pairObj.Get("publicKey"))
	_ = vm.Set("pri", pairObj.Get("privateKey"))

	enc := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.encrypt("RSAES-PKCS1-v1_5", pub, new Uint8Array([97,98,99]))
	`))
	_ = vm.Set("enc", enc)

	dec := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.decrypt("RSAES-PKCS1-v1_5", pri, enc)
	`))
	ab, ok := dec.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected decrypt type: %T", dec.Export())
	}
	if string(ab.Bytes()) != "abc" {
		t.Fatalf("unexpected plaintext: %q", string(ab.Bytes()))
	}
}

func TestPBKDF2DeriveBitsSHA1(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	baseKey := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey(
			"raw",
			new Uint8Array([112,97,115,115,119,111,114,100]),
			"PBKDF2",
			false,
			["deriveBits", "deriveKey"]
		)
	`))
	_ = vm.Set("baseKey", baseKey)

	bits := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits(
			{name:"PBKDF2", salt:new Uint8Array([115,97,108,116]), iterations:1, hash:"SHA-1"},
			baseKey,
			160
		)
	`))
	ab, ok := bits.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected deriveBits type: %T", bits.Export())
	}
	if got := hex.EncodeToString(ab.Bytes()); got != "0c60c80f961f0e71f3a9b524af6012062fe037a6" {
		t.Fatalf("unexpected pbkdf2 output: %s", got)
	}
}

func TestHKDFDeriveBitsSHA256(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	baseKey := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey(
			"raw",
			new Uint8Array([105,107,109]),
			"HKDF",
			false,
			["deriveBits","deriveKey"]
		)
	`))
	_ = vm.Set("baseKey", baseKey)

	bits := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits(
			{name:"HKDF", hash:"SHA-256", salt:new Uint8Array([115,97,108,116]), info:new Uint8Array([105,110,102,111])},
			baseKey,
			128
		)
	`))
	ab, ok := bits.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected deriveBits type: %T", bits.Export())
	}

	expected := make([]byte, 16)
	r := hkdf.New(sha256.New, []byte("ikm"), []byte("salt"), []byte("info"))
	if _, err := io.ReadFull(r, expected); err != nil {
		t.Fatalf("hkdf expected read failed: %v", err)
	}
	if got := ab.Bytes(); hex.EncodeToString(got) != hex.EncodeToString(expected) {
		t.Fatalf("unexpected hkdf output: %s", hex.EncodeToString(got))
	}
}

func TestAESCTREncryptDecrypt(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"AES-CTR", length:128},
			true,
			["encrypt","decrypt"]
		)
	`))
	_ = vm.Set("k", k)
	mustRun(t, vm, `globalThis.counter = new Uint8Array(16); crypto.getRandomValues(globalThis.counter);`)

	enc := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.encrypt(
			{name:"AES-CTR", counter: globalThis.counter, length: 64},
			k,
			new Uint8Array([104,101,108,108,111])
		)
	`))
	_ = vm.Set("enc", enc)

	dec := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.decrypt(
			{name:"AES-CTR", counter: globalThis.counter, length: 64},
			k,
			enc
		)
	`))
	ab, ok := dec.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected decrypt type: %T", dec.Export())
	}
	if string(ab.Bytes()) != "hello" {
		t.Fatalf("unexpected plaintext: %q", string(ab.Bytes()))
	}
}

func TestECDSAGenerateSignVerify(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"ECDSA", namedCurve:"P-256"},
			true,
			["sign","verify"]
		)
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pub", pairObj.Get("publicKey"))
	_ = vm.Set("pri", pairObj.Get("privateKey"))

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign(
			{name:"ECDSA", hash:"SHA-256"},
			pri,
			new Uint8Array([1,2,3,4,5])
		)
	`))
	_ = vm.Set("sig", sig)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify(
			{name:"ECDSA", hash:"SHA-256"},
			pub,
			sig,
			new Uint8Array([1,2,3,4,5])
		)
	`))
	if !okVal.ToBoolean() {
		t.Fatal("ecdsa verify failed")
	}
}

func TestECDSASignatureFormatRaw(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"ECDSA", namedCurve:"P-256"},
			true,
			["sign","verify"]
		)
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pub", pairObj.Get("publicKey"))
	_ = vm.Set("pri", pairObj.Get("privateKey"))

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign(
			{name:"ECDSA", hash:"SHA-256"},
			pri,
			new Uint8Array([1,2,3,4,5])
		)
	`))
	ab, ok := sig.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected signature type: %T", sig.Export())
	}
	if len(ab.Bytes()) != 64 {
		t.Fatalf("unexpected ecdsa raw signature length: %d", len(ab.Bytes()))
	}
	_ = vm.Set("sig", sig)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify(
			{name:"ECDSA", hash:"SHA-256"},
			pub,
			sig,
			new Uint8Array([1,2,3,4,5])
		)
	`))
	if !okVal.ToBoolean() {
		t.Fatal("ecdsa raw signature verify failed")
	}
}

func TestWrapUnwrapKey(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	keyToWrap := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"AES-CBC", length:128}, true, ["encrypt","decrypt"])
	`))
	_ = vm.Set("keyToWrap", keyToWrap)
	wrapKey := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"AES-GCM", length:128}, true, ["encrypt","decrypt","wrapKey","unwrapKey"])
	`))
	_ = vm.Set("wrapKey", wrapKey)
	mustRun(t, vm, `globalThis.ivWrap = new Uint8Array(12); crypto.getRandomValues(globalThis.ivWrap);`)

	wrapped := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.wrapKey("raw", keyToWrap, wrapKey, {name:"AES-GCM", iv: globalThis.ivWrap})
	`))
	_ = vm.Set("wrapped", wrapped)

	unwrapped := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.unwrapKey(
			"raw",
			wrapped,
			wrapKey,
			{name:"AES-GCM", iv: globalThis.ivWrap},
			{name:"AES-CBC"},
			true,
			["encrypt","decrypt"]
		)
	`))
	_ = vm.Set("unwrapped", unwrapped)

	rawOrig := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", keyToWrap)`))
	rawUnwrapped := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", unwrapped)`))
	a, ok := rawOrig.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected raw orig type: %T", rawOrig.Export())
	}
	b, ok := rawUnwrapped.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected raw unwrapped type: %T", rawUnwrapped.Export())
	}
	if hex.EncodeToString(a.Bytes()) != hex.EncodeToString(b.Bytes()) {
		t.Fatal("wrapped/unwrapped key mismatch")
	}
}

func TestECDHDeriveBits(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	aPair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"ECDH", namedCurve:"P-256"}, true, ["deriveBits"])
	`))
	bPair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"ECDH", namedCurve:"P-256"}, true, ["deriveBits"])
	`))
	aObj := aPair.ToObject(vm)
	bObj := bPair.ToObject(vm)
	_ = vm.Set("aPriv", aObj.Get("privateKey"))
	_ = vm.Set("aPub", aObj.Get("publicKey"))
	_ = vm.Set("bPriv", bObj.Get("privateKey"))
	_ = vm.Set("bPub", bObj.Get("publicKey"))

	ab := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits({name:"ECDH", public:bPub}, aPriv, 128)
	`))
	ba := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits({name:"ECDH", public:aPub}, bPriv, 128)
	`))

	abBuf, ok := ab.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected ab type: %T", ab.Export())
	}
	baBuf, ok := ba.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected ba type: %T", ba.Export())
	}
	if hex.EncodeToString(abBuf.Bytes()) != hex.EncodeToString(baBuf.Bytes()) {
		t.Fatal("ecdh shared secret mismatch")
	}
}

func TestAESKWEncryptDecrypt(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"AES-KW", length:128}, true, ["encrypt","decrypt","wrapKey","unwrapKey"])
	`))
	_ = vm.Set("k", k)

	enc := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.encrypt("AES-KW", k, new Uint8Array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))
	`))
	_ = vm.Set("enc", enc)

	dec := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.decrypt("AES-KW", k, enc)
	`))
	ab, ok := dec.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected aes-kw decrypt type: %T", dec.Export())
	}
	if got := hex.EncodeToString(ab.Bytes()); got != "0102030405060708090a0b0c0d0e0f10" {
		t.Fatalf("unexpected aes-kw plaintext: %s", got)
	}
}

func TestPKCS1ImportExport(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"RSASSA-PKCS1-v1_5", modulusLength:1024, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256"},
			true,
			["sign","verify"]
		)
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pub", pairObj.Get("publicKey"))
	_ = vm.Set("pri", pairObj.Get("privateKey"))

	pkcs1Priv := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("pkcs1", pri)`))
	_ = vm.Set("pkcs1Priv", pkcs1Priv)

	imported := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("pkcs1", pkcs1Priv, {name:"RSASSA-PKCS1-v1_5", hash:"SHA-256"}, true, ["sign"])
	`))
	_ = vm.Set("importedPri", imported)

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign("RSASSA-PKCS1-v1_5", importedPri, new Uint8Array([7,8,9]))
	`))
	_ = vm.Set("sig2", sig)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify("RSASSA-PKCS1-v1_5", pub, sig2, new Uint8Array([7,8,9]))
	`))
	if !okVal.ToBoolean() {
		t.Fatal("pkcs1 import/export verify failed")
	}
}

func TestRSAJWKImportWithoutPQ(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"RSASSA-PKCS1-v1_5", modulusLength:1024, publicExponent:new Uint8Array([1,0,1]), hash:"SHA-256"},
			true,
			["sign","verify"]
		)
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pub", pairObj.Get("publicKey"))
	_ = vm.Set("pri", pairObj.Get("privateKey"))

	jwkVal := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("jwk", pri)`))
	jwkObj := jwkVal.ToObject(vm)
	_ = jwkObj.Delete("p")
	_ = jwkObj.Delete("q")
	_ = jwkObj.Delete("dp")
	_ = jwkObj.Delete("dq")
	_ = jwkObj.Delete("qi")
	_ = vm.Set("jwkNoPQ", jwkObj)

	imported := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("jwk", jwkNoPQ, {name:"RSASSA-PKCS1-v1_5", hash:"SHA-256"}, true, ["sign"])
	`))
	_ = vm.Set("importedPri", imported)

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign("RSASSA-PKCS1-v1_5", importedPri, new Uint8Array([7,8,9]))
	`))
	_ = vm.Set("sigJwk", sig)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify("RSASSA-PKCS1-v1_5", pub, sigJwk, new Uint8Array([7,8,9]))
	`))
	if !okVal.ToBoolean() {
		t.Fatal("rsa jwk import without p/q verify failed")
	}
}

func TestRSAGenerateKeyPublicExponentVariants(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pairE3 := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"RSASSA-PKCS1-v1_5", modulusLength:1024, publicExponent:new Uint8Array([3]), hash:"SHA-256"},
			true,
			["sign","verify"]
		)
	`))
	pairE3Obj := pairE3.ToObject(vm)
	_ = vm.Set("pubE3", pairE3Obj.Get("publicKey"))
	_ = vm.Set("priE3", pairE3Obj.Get("privateKey"))

	sigE3 := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign("RSASSA-PKCS1-v1_5", priE3, new Uint8Array([1,3,3,7]))
	`))
	_ = vm.Set("sigE3", sigE3)

	okE3 := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify("RSASSA-PKCS1-v1_5", pubE3, sigE3, new Uint8Array([1,3,3,7]))
	`))
	if !okE3.ToBoolean() {
		t.Fatal("rsa generateKey with exponent=3 verify failed")
	}

	pairLongExp := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"RSASSA-PKCS1-v1_5", modulusLength:1024, publicExponent:new Uint8Array([0,0,1,0,1]), hash:"SHA-256"},
			true,
			["sign","verify"]
		)
	`))
	pairLongObj := pairLongExp.ToObject(vm)
	_ = vm.Set("pubLongExp", pairLongObj.Get("publicKey"))
	_ = vm.Set("priLongExp", pairLongObj.Get("privateKey"))

	sigLong := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign("RSASSA-PKCS1-v1_5", priLongExp, new Uint8Array([2,4,6,8]))
	`))
	_ = vm.Set("sigLong", sigLong)

	okLong := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify("RSASSA-PKCS1-v1_5", pubLongExp, sigLong, new Uint8Array([2,4,6,8]))
	`))
	if !okLong.ToBoolean() {
		t.Fatal("rsa generateKey with long exponent bytes verify failed")
	}
}

func TestSEC1ImportExport(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"ECDSA", namedCurve:"P-256"},
			true,
			["sign","verify"]
		)
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pub", pairObj.Get("publicKey"))
	_ = vm.Set("pri", pairObj.Get("privateKey"))

	sec1Priv := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("sec1", pri)`))
	_ = vm.Set("sec1Priv", sec1Priv)

	imported := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("sec1", sec1Priv, {name:"ECDSA", namedCurve:"P-256"}, true, ["sign"])
	`))
	_ = vm.Set("importedPri", imported)

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign({name:"ECDSA", hash:"SHA-256"}, importedPri, new Uint8Array([7,8,9]))
	`))
	_ = vm.Set("sig2", sig)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify({name:"ECDSA", hash:"SHA-256"}, pub, sig2, new Uint8Array([7,8,9]))
	`))
	if !okVal.ToBoolean() {
		t.Fatal("sec1 import/export verify failed")
	}
}

func TestECDSARawPublicImportExport(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"ECDSA", namedCurve:"P-256"},
			true,
			["sign","verify"]
		)
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pub", pairObj.Get("publicKey"))
	_ = vm.Set("pri", pairObj.Get("privateKey"))

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign({name:"ECDSA", hash:"SHA-256"}, pri, new Uint8Array([11,22,33]))
	`))
	_ = vm.Set("sig", sig)

	rawPub := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", pub)`))
	_ = vm.Set("rawPub", rawPub)

	importedPub := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("raw", rawPub, {name:"ECDSA", namedCurve:"P-256"}, true, ["verify"])
	`))
	_ = vm.Set("importedPub", importedPub)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify({name:"ECDSA", hash:"SHA-256"}, importedPub, sig, new Uint8Array([11,22,33]))
	`))
	if !okVal.ToBoolean() {
		t.Fatal("ecdsa raw public import/export verify failed")
	}
}

func TestEd25519RawPublicImportExport(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"Ed25519"}, true, ["sign","verify"])
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pubEd", pairObj.Get("publicKey"))
	_ = vm.Set("priEd", pairObj.Get("privateKey"))

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign("Ed25519", priEd, new Uint8Array([9,8,7,6]))
	`))
	_ = vm.Set("sigEd", sig)

	rawPub := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", pubEd)`))
	_ = vm.Set("rawPub", rawPub)

	importedPub := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("raw", rawPub, "Ed25519", true, ["verify"])
	`))
	_ = vm.Set("importedPub", importedPub)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify("Ed25519", importedPub, sigEd, new Uint8Array([9,8,7,6]))
	`))
	if !okVal.ToBoolean() {
		t.Fatal("ed25519 raw public import/export verify failed")
	}
}

func TestEd25519RawPrivateImportSign(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	importedPri := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey(
			"raw",
			new Uint8Array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]),
			"Ed25519",
			true,
			["sign"]
		)
	`))
	_ = vm.Set("importedPri", importedPri)

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign("Ed25519", importedPri, new Uint8Array([3,1,4,1,5,9]))
	`))
	_ = vm.Set("sig", sig)

	pubRaw := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", importedPri)`))
	_ = vm.Set("pubRaw", pubRaw)

	importedPub := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("raw", pubRaw, "Ed25519", true, ["verify"])
	`))
	_ = vm.Set("importedPub", importedPub)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify("Ed25519", importedPub, sig, new Uint8Array([3,1,4,1,5,9]))
	`))
	if !okVal.ToBoolean() {
		t.Fatal("ed25519 raw private import verify failed")
	}
}

func TestX25519RawPublicImportForDerive(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	aPair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"X25519"}, true, ["deriveBits"])
	`))
	bPair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"X25519"}, true, ["deriveBits"])
	`))
	aObj := aPair.ToObject(vm)
	bObj := bPair.ToObject(vm)
	_ = vm.Set("aPrivX", aObj.Get("privateKey"))
	_ = vm.Set("aPubX", aObj.Get("publicKey"))
	_ = vm.Set("bPrivX", bObj.Get("privateKey"))
	_ = vm.Set("bPubX", bObj.Get("publicKey"))

	rawBPub := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", bPubX)`))
	_ = vm.Set("rawBPub", rawBPub)
	importedBPub := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("raw", rawBPub, "X25519", true, ["deriveBits"])
	`))
	_ = vm.Set("importedBPub", importedBPub)

	ab := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits({name:"X25519", public:importedBPub}, aPrivX, 256)
	`))
	ba := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits({name:"X25519", public:aPubX}, bPrivX, 256)
	`))
	abBuf, ok := ab.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected x25519 raw-import ab type: %T", ab.Export())
	}
	baBuf, ok := ba.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected x25519 raw-import ba type: %T", ba.Export())
	}
	if hex.EncodeToString(abBuf.Bytes()) != hex.EncodeToString(baBuf.Bytes()) {
		t.Fatal("x25519 raw public import derive mismatch")
	}
}

func TestX25519RawPrivateImportForDerive(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	aPriv := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey(
			"raw",
			new Uint8Array([3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137]),
			{name:"X25519", keyType:"private"},
			true,
			["deriveBits"]
		)
	`))
	bPriv := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey(
			"raw",
			new Uint8Array([139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,2,6,10,14,18,22,26,30,34,38,42]),
			{name:"X25519", keyType:"private"},
			true,
			["deriveBits"]
		)
	`))
	_ = vm.Set("aPriv", aPriv)
	_ = vm.Set("bPriv", bPriv)

	aPubRaw := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", aPriv)`))
	bPubRaw := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", bPriv)`))
	_ = vm.Set("aPubRaw", aPubRaw)
	_ = vm.Set("bPubRaw", bPubRaw)

	aPub := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("raw", aPubRaw, "X25519", true, ["deriveBits"])
	`))
	bPub := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey("raw", bPubRaw, "X25519", true, ["deriveBits"])
	`))
	_ = vm.Set("aPub", aPub)
	_ = vm.Set("bPub", bPub)

	ab := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits({name:"X25519", public:bPub}, aPriv, 256)
	`))
	ba := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits({name:"X25519", public:aPub}, bPriv, 256)
	`))
	abBuf, ok := ab.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected x25519 raw-private ab type: %T", ab.Export())
	}
	baBuf, ok := ba.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected x25519 raw-private ba type: %T", ba.Export())
	}
	if hex.EncodeToString(abBuf.Bytes()) != hex.EncodeToString(baBuf.Bytes()) {
		t.Fatal("x25519 raw private import derive mismatch")
	}
}

func TestEd25519SignVerify(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	pair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"Ed25519"}, true, ["sign","verify"])
	`))
	pairObj := pair.ToObject(vm)
	_ = vm.Set("pubEd", pairObj.Get("publicKey"))
	_ = vm.Set("priEd", pairObj.Get("privateKey"))

	sig := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.sign("Ed25519", priEd, new Uint8Array([1,2,3,4]))
	`))
	_ = vm.Set("sigEd", sig)

	okVal := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.verify("Ed25519", pubEd, sigEd, new Uint8Array([1,2,3,4]))
	`))
	if !okVal.ToBoolean() {
		t.Fatal("ed25519 verify failed")
	}
}

func TestX25519DeriveBits(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	aPair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"X25519"}, true, ["deriveBits"])
	`))
	bPair := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey({name:"X25519"}, true, ["deriveBits"])
	`))
	aObj := aPair.ToObject(vm)
	bObj := bPair.ToObject(vm)
	_ = vm.Set("aPrivX", aObj.Get("privateKey"))
	_ = vm.Set("aPubX", aObj.Get("publicKey"))
	_ = vm.Set("bPrivX", bObj.Get("privateKey"))
	_ = vm.Set("bPubX", bObj.Get("publicKey"))

	ab := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits({name:"X25519", public:bPubX}, aPrivX, 256)
	`))
	ba := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.deriveBits({name:"X25519", public:aPubX}, bPrivX, 256)
	`))
	abBuf, ok := ab.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected x25519 ab type: %T", ab.Export())
	}
	baBuf, ok := ba.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected x25519 ba type: %T", ba.Export())
	}
	if hex.EncodeToString(abBuf.Bytes()) != hex.EncodeToString(baBuf.Bytes()) {
		t.Fatal("x25519 shared secret mismatch")
	}
}

func TestImportExportRawRoundTrip(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.importKey(
			"raw",
			new Uint8Array([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]),
			"AES-CBC",
			true,
			["encrypt", "decrypt"]
		)
	`))
	_ = vm.Set("k", k)

	raw := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("raw", k)`))
	ab, ok := raw.Export().(goja.ArrayBuffer)
	if !ok {
		t.Fatalf("unexpected export type: %T", raw.Export())
	}
	if got := hex.EncodeToString(ab.Bytes()); got != "0102030405060708090a0b0c0d0e0f10" {
		t.Fatalf("unexpected export bytes: %s", got)
	}
}

func TestExportJWKIncludesAlg(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	k := mustPromiseFulfilled(t, mustRun(t, vm, `
		crypto.subtle.generateKey(
			{name:"AES-GCM", length:256},
			true,
			["encrypt", "decrypt"]
		)
	`))
	_ = vm.Set("k", k)

	jwk := mustPromiseFulfilled(t, mustRun(t, vm, `crypto.subtle.exportKey("jwk", k)`))
	obj := jwk.ToObject(vm)

	if got := obj.Get("kty").String(); got != "oct" {
		t.Fatalf("unexpected jwk.kty: %s", got)
	}
	if got := obj.Get("alg").String(); got != "A256GCM" {
		t.Fatalf("unexpected jwk.alg: %s", got)
	}
}

func TestRequireCryptoModule(t *testing.T) {
	vm := goja.New()
	reg := new(require.Registry)
	reg.RegisterNativeModule("crypto", Require)
	reg.Enable(vm)

	v := mustRun(t, vm, `
		(function() {
			const c = require("crypto");
			if (c !== crypto) return false;
			if (typeof c.getRandomValues !== "function") return false;
			if (typeof c.randomUUID !== "function") return false;
			if (typeof c.subtle.digest !== "function") return false;
			if (typeof c.subtle.generateKey !== "function") return false;
			if (typeof c.subtle.importKey !== "function") return false;
			if (typeof c.subtle.exportKey !== "function") return false;
			if (typeof c.subtle.sign !== "function") return false;
			if (typeof c.subtle.verify !== "function") return false;
			if (typeof c.subtle.encrypt !== "function") return false;
			if (typeof c.subtle.decrypt !== "function") return false;
				if (typeof c.subtle.deriveBits !== "function") return false;
				if (typeof c.subtle.deriveKey !== "function") return false;
				if (typeof c.subtle.wrapKey !== "function") return false;
				if (typeof c.subtle.unwrapKey !== "function") return false;
				// Newer compatibility algorithms
				// Ed25519 / X25519 are exercised in dedicated tests.
				return true;
			})()
		`)
	if !v.ToBoolean() {
		t.Fatal("crypto module is not exposed as expected")
	}
}

func TestRandomUUIDFormat(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	v := mustRun(t, vm, `crypto.randomUUID()`)
	uuid := v.String()
	pat := regexp.MustCompile(`^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`)
	if !pat.MatchString(uuid) {
		t.Fatalf("invalid UUIDv4: %s", uuid)
	}
}

func TestTextEncoderTextDecoderGlobals(t *testing.T) {
	vm := goja.New()
	Enable(vm)

	v := mustRun(t, vm, `
		(function() {
			const te = new TextEncoder();
			const td = new TextDecoder();
			const bytes = te.encode("Hello, Web Crypto!");
			if (!(bytes instanceof Uint8Array)) return "not-uint8array";
			return td.decode(bytes);
		})()
	`)
	if got := v.String(); got != "Hello, Web Crypto!" {
		t.Fatalf("unexpected encode/decode result: %q", got)
	}
}
